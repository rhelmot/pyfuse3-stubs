from typing import Any, NewType, Union, Sequence, Tuple, Optional, overload
import logging
import pickle

FileHandleT = NewType("FileHandleT", int)
FileNameT = NewType("FileNameT", bytes)
FlagT = NewType("FlagT", int)
InodeT = NewType("InodeT", int)
ModeT = NewType("ModeT", int)

ENOATTR: int
RENAME_EXCHANGE: int
RENAME_NOREPLACE: int
ROOT_INODE: InodeT
_NANOS_PER_SEC: int
_session_loop: function
async_wrapper: function
default_options: frozenset
fse: str
g: dict
log: logging.Logger

async def main(): ...

trio_token: None

class EntryAttributes:
    attr_timeout: Union[float, int]
    entry_timeout: Union[float, int]
    generation: int
    st_atime_ns: int
    st_birthtime_ns: int
    st_blksize: int
    st_blocks: int
    st_ctime_ns: int
    st_gid: int
    st_ino: int
    st_mode: int
    st_mtime_ns: int
    st_nlink: int
    st_rdev: int
    st_size: int
    st_uid: int

class FUSEError(Exception):
    def __init__(self, errno: int): ...
    errno: int
    errno_: int

class FileInfo:
    direct_io: bool
    fh: FileHandleT
    keep_cache: bool
    nonseekable: bool

class Operations:
    supports_dot_lookup: bool
    enable_writeback_cache: bool
    enable_acl: bool
    def init(self) -> None: ...
    async def lookup(
        self, parent_inode: InodeT, name: FileNameT, ctx: RequestContext
    ) -> EntryAttributes: ...
    async def forget(self, inode_list: Sequence[Tuple[InodeT, int]]) -> None: ...
    async def getattr(self, inode: InodeT, ctx: RequestContext) -> EntryAttributes: ...
    async def setattr(
        self,
        inode: InodeT,
        attr: EntryAttributes,
        fields: SetattrFields,
        fh: Optional[FileHandleT],
        ctx: RequestContext,
    ) -> EntryAttributes: ...
    async def readlink(self, inode: InodeT, ctx: RequestContext) -> FileNameT: ...
    async def mknod(
        self,
        parent_inode: InodeT,
        name: FileNameT,
        mode: ModeT,
        rdev: int,
        ctx: RequestContext,
    ) -> EntryAttributes: ...
    async def mkdir(
        self, parent_inode: InodeT, name: FileNameT, mode: ModeT, ctx: RequestContext
    ) -> EntryAttributes: ...
    async def unlink(
        self, parent_inode: InodeT, name: FileNameT, ctx: RequestContext
    ) -> None: ...
    async def rmdir(
        self, parent_inode: InodeT, name: FileNameT, ctx: RequestContext
    ) -> None: ...
    async def symlink(
        self,
        parent_inode: InodeT,
        name: FileNameT,
        target: FileNameT,
        ctx: RequestContext,
    ) -> EntryAttributes: ...
    async def rename(
        self,
        parent_inode_old: InodeT,
        name_old: str,
        parent_inode_new: InodeT,
        name_new: str,
        flags: FlagT,
        ctx: RequestContext,
    ) -> None: ...
    async def link(
        self,
        inode: InodeT,
        new_parent_inode: InodeT,
        new_name: FileNameT,
        ctx: RequestContext,
    ) -> EntryAttributes: ...
    async def open(
        self, inode: InodeT, flags: FlagT, ctx: RequestContext
    ) -> FileInfo: ...
    async def read(self, fh: FileHandleT, off: int, size: int) -> bytes: ...
    async def write(self, fh: FileHandleT, off: int, buf: bytes) -> int: ...
    async def flush(self, fh: FileHandleT) -> None: ...
    async def release(self, fh: FileHandleT) -> None: ...
    async def fsync(self, fh: FileHandleT, datasync: bool) -> None: ...
    async def opendir(self, inode: InodeT, ctx: RequestContext) -> FileHandleT: ...
    async def readdir(
        self, fh: FileHandleT, start_id: int, token: ReaddirToken
    ) -> None: ...
    async def releasedir(self, fh: FileHandleT) -> None: ...
    async def fsyncdir(self, fh: FileHandleT, datasync: bool) -> None: ...
    async def statfs(self, ctx: RequestContext) -> StatvfsData: ...
    def stacktrace(self) -> None: ...
    async def setxattr(
        self, inode: InodeT, name: bytes, value: bytes, ctx: RequestContext
    ) -> None: ...
    async def getxattr(
        self, inode: InodeT, name: bytes, ctx: RequestContext
    ) -> bytes: ...
    async def listxattr(
        self, inode: InodeT, ctx: RequestContext
    ) -> Sequence[bytes]: ...
    async def removexattr(
        self, inode: InodeT, name: bytes, ctx: RequestContext
    ) -> None: ...
    async def access(self, inode: InodeT, mode: ModeT, ctx: RequestContext) -> bool: ...
    async def create(
        self,
        parent_inode: InodeT,
        name: FileNameT,
        mode: ModeT,
        flags: FlagT,
        ctx: RequestContext,
    ) -> Tuple[FileInfo, EntryAttributes]: ...

class PicklingError(pickle.PickleError): ...

class ReaddirToken:
    @classmethod
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class RequestContext:
    gid: int
    pid: int
    uid: int
    umask: int

class SetattrFields:
    update_atime: bool
    update_ctime: bool
    update_gid: bool
    update_mode: bool
    update_mtime: bool
    update_size: bool
    update_uid: bool

class StatvfsData:
    f_bavail: int
    f_bfree: int
    f_blocks: int
    f_bsize: int
    f_favail: int
    f_ffree: int
    f_files: int
    f_frsize: int
    f_namemax: int

class _Container:
    pass

class _WorkerData:
    pass

def __pyx_unpickle_RequestContext(
    __pyx_type, long__pyx_checksum, __pyx_state
) -> Any: ...
def __pyx_unpickle__WorkerData(__pyx_type, long__pyx_checksum, __pyx_state) -> Any: ...
def _notify_loop() -> Any: ...
def _wait_fuse_readable() -> Any: ...
def close(unmount=...) -> Any: ...
def fuse_access_async(_Containerc) -> Any: ...
def fuse_create_async(_Containerc, name) -> Any: ...
def fuse_flush_async(_Containerc) -> Any: ...
def fuse_fsync_async(_Containerc) -> Any: ...
def fuse_fsyncdir_async(_Containerc) -> Any: ...
def fuse_getattr_async(_Containerc) -> Any: ...
def fuse_getxattr_async(_Containerc, name) -> Any: ...
def fuse_link_async(_Containerc, newname) -> Any: ...
def fuse_listxattr_async(_Containerc) -> Any: ...
def fuse_lookup_async(_Containerc, name) -> Any: ...
def fuse_mkdir_async(_Containerc, name) -> Any: ...
def fuse_mknod_async(_Containerc, name) -> Any: ...
def fuse_open_async(_Containerc) -> Any: ...
def fuse_opendir_async(_Containerc) -> Any: ...
def fuse_read_async(_Containerc) -> Any: ...
def fuse_readdirplus_async(_Containerc) -> Any: ...
def fuse_readlink_async(_Containerc) -> Any: ...
def fuse_release_async(_Containerc) -> Any: ...
def fuse_releasedir_async(_Containerc) -> Any: ...
def fuse_removexattr_async(_Containerc, name) -> Any: ...
def fuse_rename_async(_Containerc, name, newname) -> Any: ...
def fuse_rmdir_async(_Containerc, name) -> Any: ...
def fuse_setattr_async(_Containerc, fh) -> Any: ...
def fuse_setxattr_async(_Containerc, name, value) -> Any: ...
def fuse_statfs_async(_Containerc) -> Any: ...
def fuse_symlink_async(_Containerc, name, link) -> Any: ...
def fuse_unlink_async(_Containerc, name) -> Any: ...
def fuse_write_async(_Containerc, pbuf) -> Any: ...
def fuse_write_buf_async(_Containerc, buf) -> Any: ...
def get_sup_groups(pid) -> Any: ...
def getxattr(path, name, size_tsize_guess=..., namespace=...) -> Any: ...
@overload
def init(ops, mountpoint, options=...) -> Any: ...
@overload
def init(ops, mountpoint, my_opts) -> Any: ...
def invalidate_entry(fuse_ino_tinode_p, bytesname, fuse_ino_tdeleted=...) -> Any: ...
def invalidate_entry_async(inode_p, name, deleted=..., ignore_enoent=...) -> Any: ...
def invalidate_inode(fuse_ino_tinode, attr_only=...) -> Any: ...
def listdir(path) -> Any: ...
def notify_store(inode, offset, data) -> Any: ...
def readdir_reply(
    token: ReaddirToken, name: FileNameT, attr: EntryAttributes, next_id: int
) -> Any: ...
def setxattr(path, name, bytesvalue, namespace=...) -> Any: ...
def syncfs(path) -> Any: ...
def terminate() -> Any: ...
